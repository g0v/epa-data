// Generated by LiveScript 1.2.0
var json_filename, cache_dir, raw_dir, fs, landno, ref$, map, filter, join, keys, split, unique, section, areaPattern, sectionPattern, parseLandno, data, annoI, landnoI, geoJSONize;
json_filename = '土壤及地下水污染管制區公告資料.json';
cache_dir = 'cache';
raw_dir = 'raw';
fs = require('fs');
landno = require('./lib/landno');
ref$ = require('prelude-ls'), map = ref$.map, filter = ref$.filter, join = ref$.join, keys = ref$.keys, split = ref$.split, unique = ref$.unique;
section = JSON.parse(
fs.readFileSync('raw/section.json'));
areaPattern = function(city){
  return function(s){
    return '(' + s + ')';
  }(
  join('|')(
  map(function(a){
    return a.replace(city, '');
  })(
  filter(function(a){
    return a.search(city) > -1;
  })(
  keys(
  section.area)))));
};
sectionPattern = function(city, area){
  return function(s){
    return '(' + s + ')';
  }(
  join('|')(
  keys(
  section.section[section.area[city + area]])));
};
parseLandno = function(city, text){
  var landno, p, pattern, result, area, p2, pattern2, result2, sec;
  landno = [];
  p = areaPattern(city) + '([^\\d]+(?:、|\\d|\\-)+)';
  pattern = new RegExp(p, 'g');
  while ((result = pattern.exec(text)) !== null) {
    result[0];
    area = result[1];
    p2 = sectionPattern(city, area) + '((?:、|\\d|\\-)*)';
    pattern2 = new RegExp(p2, 'g');
    while ((result2 = pattern2.exec(result[2])) !== null) {
      result2[0];
      sec = result2[1];
      landno = landno.concat(map(fn$, split('、', result2[2])));
    }
  }
  landno = unique(landno);
  return map(function(n){
    return split('|', n);
  }, landno);
  function fn$(n){
    return join('|', [city, area, sec, n]);
  }
};
data = map(function(d){
  d.LandNo = parseLandno(d.County, d.AnnoTitle + d.AnnoContent);
  return d;
})(
JSON.parse(
fs.readFileSync('cache/' + json_filename)));
annoI = 0;
landnoI = 0;
geoJSONize = function(data, ending){
  var processLandno, processAnno;
  annoI = 0;
  landnoI = 0;
  processLandno = function(ending){
    if (landnoI === data[annoI].LandNo.length) {
      return ending();
    } else {
      console.log(
      '(' + annoI + ',' + landnoI + ') ' + join('', data[annoI].LandNo[landnoI]));
      return landno.geoJSON(join('', data[annoI].LandNo[landnoI]), function(err, d){
        if (!(err || !d)) {
          data[annoI].points.push(d);
        }
        ++landnoI;
        return processLandno(ending);
      });
    }
  };
  processAnno = function(ending){
    if (annoI === data.length) {
      return ending({
        type: 'FeatureCollection',
        features: filter(function(d){
          return d.geometry.coordinates.length > 0;
        })(
        data)
      });
    } else {
      data[annoI].points = [];
      return processLandno(function(){
        if (data[annoI].points.length === 1) {
          data[annoI] = {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: data[annoI].points[0]
            },
            properties: data[annoI]
          };
        } else {
          data[annoI] = {
            type: 'Feature',
            geometry: {
              type: 'MultiPoint',
              coordinates: data[annoI].points
            },
            properties: data[annoI]
          };
        }
        delete data[annoI].points;
        ++annoI;
        landnoI = 0;
        return processAnno(ending);
      });
    }
  };
  data[annoI].points = [];
  return processAnno(ending);
};
geoJSONize(filter(function(d){
  return d.LandNo.length > 0;
}, data), function(data){
  return fs.writeFileSync('raw/' + json_filename, JSON.stringify(
  data));
});